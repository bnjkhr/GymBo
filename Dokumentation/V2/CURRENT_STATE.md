# GymBo V2 - Aktueller Stand (2025-10-23)

**Status:** ‚úÖ MVP PRODUCTION-READY! Exercise Reordering + Auto-Finish + Production Fixes  
**Architektur:** Clean Architecture (4 Layers) + iOS 17 @Observable  
**Design:** Workout Picker + ScrollView Active Workout + Drag & Drop Reordering

‚ö†Ô∏è **CRITICAL:** SwiftData Migration Support NICHT implementiert! Siehe [SWIFTDATA_MIGRATION_STRATEGY.md](SWIFTDATA_MIGRATION_STRATEGY.md)  
üî¥ **Risk:** Schema Changes f√ºhren zu Datenverlust bei Production Users!

**Letzte Session (2025-10-23 - Session 6 - PRODUCTION-READY REORDERING):**
- ‚úÖ Exercise Reordering Feature (Drag & Drop mit permanentem Speichern)
- ‚úÖ ReorderExercisesSheet (isolierte Modal-View)
- ‚úÖ Permanent Save Toggle (Reihenfolge dauerhaft speichern)
- ‚úÖ Auto-Finish Exercise (wenn alle S√§tze completed)
- ‚úÖ **PRODUCTION-READY FIXES:**
  - StartSessionUseCase verwendet expliziten orderIndex
  - WorkoutMapper nutzt in-place updates
  - SessionMapper aktualisiert orderIndex korrekt
  - CompleteSetUseCase auto-finisht √úbungen
- ‚úÖ SwiftUI Observable Fix (Force UI update via nil assignment)
- ‚úÖ MockWorkoutRepository updateExerciseOrder() Implementation

**Session 5 (2025-10-23 - WORKOUT REPOSITORY):**
- ‚úÖ Workout Repository mit vollst√§ndiger Clean Architecture
- ‚úÖ Workout Picker UI mit Favoriten-Support
- ‚úÖ StartSessionUseCase l√§dt echte Workouts
- ‚úÖ Progressive Overload mit lastUsed Values
- ‚úÖ Workout Seed Data (Push/Pull/Legs)
- ‚úÖ WorkoutStore (@Observable) f√ºr UI
- ‚úÖ 13 neue Dateien, 7 ge√§ndert, ~1500 LOC

**Session 4 (2025-10-23):**
- ‚úÖ Add Set Feature (Quick-Add Field + Plus Button)
- ‚úÖ Delete Set Feature (Long-Press Context Menu)
- ‚úÖ AddSetUseCase + RemoveSetUseCase mit Clean Architecture
- ‚úÖ Regex Parser f√ºr Quick-Add Field ("100 x 8" Format)
- ‚úÖ Business Rules (Cannot delete last set)
- ‚úÖ Haptic Feedback (Success + Impact)

**Session 3 (2025-10-23):**
- ‚úÖ "Update All Sets" Feature (Toggle in EditSetSheet)
- ‚úÖ Alle incomplete Sets auf einmal aktualisieren
- ‚úÖ Mark All Complete Bug Fix (UI Refresh)
- ‚úÖ Workout Summary Persistence Fix
- ‚úÖ Equipment Display in UI
- ‚úÖ UpdateAllSetsUseCase mit Clean Architecture

**Session 2 (2025-10-23):**
- ‚úÖ Exercise Names in UI (aus Datenbank geladen)
- ‚úÖ Last Used Values beim Session Start (Progressive Overload!)
- ‚úÖ Sofortiges UI Update nach Save (Forced Observable Update)
- ‚úÖ Rounded Fonts entfernt (Standard System Font)
- ‚úÖ Kompletter Progressive Overload Cycle funktioniert!

**Session 1 (2025-10-23):**
- ‚úÖ Editable Weight/Reps mit Sheet-Based UI
- ‚úÖ Exercise History Persistence (lastUsedWeight/Reps)
- ‚úÖ Exercise Seeding (3 Test-√úbungen)
- ‚úÖ Kompletter End-to-End Workflow funktioniert

---

## üìä Implementierungsstatus

### ‚úÖ NEU IMPLEMENTIERT (Session 6 - 2025-10-23 - PRODUCTION-READY REORDERING)

**1. Exercise Reordering Feature (Full Implementation)**
- ‚úÖ **ReorderExercisesSheet** - Isolierte Modal-View f√ºr Drag & Drop
  - Dedicated List mit `.onMove()` (verhindert Button-Auto-Trigger Bug)
  - Live Preview der neuen Reihenfolge
  - Toggle "Reihenfolge dauerhaft speichern"
  - "Fertig" / "Abbrechen" Buttons
  - Toolbar mit Reorder-Button (arrow.up.arrow.down Icon)
  
- ‚úÖ **SessionStore.reorderExercises()** - Komplett √ºberarbeitet
  - Neue Signatur: `reorderExercises(reorderedExercises: [DomainSessionExercise], savePermanently: Bool)`
  - Optimistic Updates f√ºr sofortiges UI Feedback
  - **Force SwiftUI Update** via `currentSession = nil` ‚Üí `currentSession = updatedSession`
  - Conditional Persistence: Session-only ODER Workout Template
  
- ‚úÖ **WorkoutRepository.updateExerciseOrder()** - Neue Methode f√ºr permanentes Speichern
  - Direct in-place update von `orderIndex` ohne Entity-Recreation
  - Verhindert "PersistentIdentifier remapped" Errors
  - Performance optimiert
  
- ‚úÖ **ActiveWorkoutSheetView Updates**
  - Replaced List mit ScrollView + VStack (verhindert Drag-and-Drop Bug)
  - ReorderExercisesSheet als `.sheet()` Presentation
  - Reorder-Button in Toolbar
  - Sortiert nach orderIndex

**2. Auto-Finish Exercise Feature**
- ‚úÖ **CompleteSetUseCase - Auto-Finish Logic**
  ```swift
  // Auto-finish wenn alle S√§tze completed
  let allSetsCompleted = exercise.sets.allSatisfy { $0.completed }
  if allSetsCompleted && !exercise.isFinished {
      exercise.isFinished = true
  }
  // Auto un-finish wenn Satz wieder abgehakt wird
  else if !allSetsCompleted && exercise.isFinished {
      exercise.isFinished = false
  }
  ```
  
- ‚úÖ **UI Behavior**
  - Letzen Satz abhaken ‚Üí √úbung wird automatisch ausgeblendet
  - Abgehakten Satz wieder abhaken ‚Üí √úbung erscheint wieder
  - Eye-Toggle zeigt ausgeblendete √úbungen
  - "Mark All Complete" Button funktioniert weiterhin (FinishExerciseUseCase)

**3. PRODUCTION-READY FIXES (Critical f√ºr Robustheit)**

**Fix 1: StartSessionUseCase - Expliziter orderIndex**
```swift
// VORHER (fragil - nutzte Array-Position):
for (index, workoutExercise) in workoutExercises.enumerated() {
    orderIndex: index  // ‚ùå Abh√§ngig von Array-Reihenfolge
}

// NACHHER (robust - nutzt expliziten Wert):
for workoutExercise in workoutExercises {
    orderIndex: workoutExercise.orderIndex  // ‚úÖ Explizit aus Template
}
```
**Vorteil:** Funktioniert auch wenn Workout-Array unsortiert ist

**Fix 2: WorkoutMapper - In-Place Updates**
```swift
// VORHER (ineffizient + gef√§hrlich):
entity.exercises.removeAll()  // ‚ùå L√∂scht alle
entity.exercises = domain.exercises.map { toEntity($0) }  // ‚ùå Neu erstellen

// NACHHER (in-place + safe):
for domainExercise in domain.exercises {
    if let existing = entity.exercises.first(where: { $0.id == domainExercise.id }) {
        updateExerciseEntity(existing, from: domainExercise)  // ‚úÖ Update
    } else {
        entity.exercises.append(toEntity(domainExercise))  // ‚úÖ Nur neue
    }
}
entity.exercises.removeAll { !domainIds.contains($0.id) }  // ‚úÖ Nur deleted
```
**Vorteile:**
- Erh√§lt SwiftData-Beziehungen
- Keine "PersistentIdentifier remapped" Errors
- Performance optimiert
- Konsistent mit SessionMapper

**Fix 3: SessionMapper - orderIndex Updates**
```swift
private func updateExerciseEntity(_ entity: SessionExerciseEntity, from domain: DomainSessionExercise) {
    entity.exerciseId = domain.exerciseId
    entity.notes = domain.notes
    entity.restTimeToNext = domain.restTimeToNext
    entity.orderIndex = domain.orderIndex  // ‚úÖ JETZT inkludiert!
    entity.isFinished = domain.isFinished
    // ... update sets
}
```
**Vorher:** orderIndex wurde beim Update ignoriert ‚Üí Reorder nicht persistiert  
**Nachher:** orderIndex wird korrekt gespeichert

**4. Bug Fixes**
- ‚úÖ **SwiftUI Observable Detection** - Force UI update via nil assignment
- ‚úÖ **Button Auto-Trigger Bug** - List drag-and-drop triggerte Buttons automatisch
  - Root Cause: `DragAndDropBridge` in SwiftUI List
  - Fix: Reorder in separater Sheet mit isoliertem List
- ‚úÖ **Exercise nicht ausgeblendet** - Auto-finish implementiert
- ‚úÖ **MockWorkoutRepository** - updateExerciseOrder() Implementation f√ºr Tests

**5. Technical Improvements**
- ‚úÖ Konsistente Mapper-Patterns (Session + Workout)
- ‚úÖ Production-ready orderIndex Handling
- ‚úÖ In-place updates √ºberall
- ‚úÖ Future-proof f√ºr Workout-Editor UI

---

### ‚úÖ IMPLEMENTIERT (Session 5 - 2025-10-23 - WORKOUT REPOSITORY)

**1. Domain Layer - Workout Entities**
- ‚úÖ Workout.swift - Workout Template Entity
  - ID, Name, Exercises, DefaultRestTime
  - Notes, CreatedAt, UpdatedAt, IsFavorite
  - Computed: exerciseCount, totalSets, estimatedDuration
- ‚úÖ WorkoutExercise.swift - Exercise Template
  - ExerciseId, TargetSets, TargetReps, TargetWeight
  - RestTime, OrderIndex, Notes

**2. Domain Layer - Repository & Use Cases**
- ‚úÖ WorkoutRepositoryProtocol
  - save, update, fetch, fetchAll, fetchFavorites, search, delete
  - MockWorkoutRepository f√ºr Tests
- ‚úÖ GetAllWorkoutsUseCase
  - L√§dt alle Workouts sortiert (Favoriten zuerst)
- ‚úÖ GetWorkoutByIdUseCase
  - L√§dt einzelnes Workout mit Validierung

**3. Data Layer - Repository & Mapper**
- ‚úÖ SwiftDataWorkoutRepository
  - Vollst√§ndige CRUD Implementation
  - WorkoutEntity (bereits vorhanden) wird wiederverwendet
  - Favorites Filtering, Search
- ‚úÖ WorkoutMapper
  - Bidirektionales Mapping: Workout ‚Üî WorkoutEntity
  - WorkoutExercise ‚Üí WorkoutExerciseEntity Konvertierung
  - Sets werden aus targetSets generiert

**4. Presentation Layer - Store & UI**
- ‚úÖ WorkoutStore (@Observable)
  - loadWorkouts, refresh, loadWorkout(id:)
  - Computed: favoriteWorkouts, regularWorkouts
  - Error handling & loading states
- ‚úÖ HomeViewPlaceholder - Workout Picker
  - Liste aller Workouts mit Favoriten-Sektion
  - WorkoutRow Component (Icon, Name, Stats)
  - Continue Session View
  - Pull-to-refresh Support

**5. Infrastructure - Seed Data & DI**
- ‚úÖ WorkoutSeedData
  - Push Day: Bankdr√ºcken 4√ó8 @ 100kg ‚≠ê
  - Pull Day: Lat Pulldown 3√ó10 @ 80kg
  - Leg Day: Kniebeugen 4√ó12 @ 60kg ‚≠ê
- ‚úÖ DependencyContainer Updates
  - makeWorkoutRepository()
  - makeGetAllWorkoutsUseCase(), makeGetWorkoutByIdUseCase()
  - makeWorkoutStore()
  - makeStartSessionUseCase() mit WorkoutRepository
- ‚úÖ DependencyContainerEnvironmentKey
  - Environment-Support f√ºr DI Container

**6. StartSessionUseCase - Komplett √ºberarbeitet**
- ‚úÖ L√§dt echte Workouts via WorkoutRepository
- ‚úÖ convertToSessionExercises() implementiert
  - WorkoutExercise ‚Üí SessionExercise Konvertierung
  - Progressive Overload: lastUsedWeight/Reps aus ExerciseEntity
  - Fallback zu Template-Werten wenn keine History
  - Dynamische Set-Anzahl aus Workout Template
- ‚úÖ Keine Hardcoded Test-Data mehr

**7. Dokumentation f√ºr Phase 2**
- ‚úÖ PROGRESSION_FEATURE_PLAN.md
  - Vollst√§ndige Spezifikation (~14h gesch√§tzt)
  - Data Model Extensions (optional, backward compatible)
  - 3 Progression Strategien (Linear, Double, Wave)
  - Use Cases, Repositories, UI Components
  - Implementation Roadmap
- ‚úÖ PROGRESSION_QUICK_REF.md
  - Quick Reference f√ºr Phase 2
  - TL;DR: Was existiert vs. was fehlt

### ‚úÖ NEU IMPLEMENTIERT (Session 4 - 2025-10-23)

**1. Add Set Feature**
- ‚úÖ Quick-Add TextField mit Regex Parser
  - Regex: `#"(\d+(?:\.\d+)?)\s*[xX√ó]\s*(\d+)"#`
  - Beispiel: "100 x 8" ‚Üí 100.0kg, 8 reps
  - Leert sich automatisch nach Add
- ‚úÖ Plus Button f√ºr schnelles Hinzuf√ºgen
  - Nutzt letzte Set-Werte als Default
  - Deaktiviert wenn kein letztes Set vorhanden
- ‚úÖ AddSetUseCase implementiert (Clean Architecture)
  - Domain Layer: Use Case mit Business Logic
  - Fallback auf letzte Set-Werte wenn keine angegeben
  - Aktualisiert Exercise History (Progressive Overload)
  - Persistence via SessionRepository
- ‚úÖ Haptic Success Feedback beim Hinzuf√ºgen

**2. Delete Set Feature**
- ‚úÖ Long-Press Context Menu auf jedem Set
  - Zeigt "Satz l√∂schen" mit Trash Icon
  - Destructive Role (rot eingef√§rbt)
- ‚úÖ RemoveSetUseCase implementiert (Clean Architecture)
  - Business Rule: Minimum 1 Set pro Exercise
  - Validierung: Cannot remove last set
  - Proper Error Handling
- ‚úÖ Haptic Impact Feedback beim L√∂schen
- ‚úÖ UI disabled f√ºr letzten Satz

**3. Set Management Integration**
- ‚úÖ SessionStore.addSet(exerciseId, weight, reps)
- ‚úÖ SessionStore.removeSet(exerciseId, setId)
- ‚úÖ DependencyContainer Factory Methods
  - makeAddSetUseCase()
  - makeRemoveSetUseCase()
- ‚úÖ Forced Observable Updates f√ºr sofortiges UI Feedback
- ‚úÖ Compiler Timeout Fix (exerciseCardView() extraction)

### ‚úÖ NEU IMPLEMENTIERT (Session 3 - 2025-10-23)

**1. Update All Sets Feature**
- ‚úÖ Toggle "Alle S√§tze aktualisieren" in EditSetSheet
  - Orange Toggle (App Accent Color)
  - German UI Text: "Werte f√ºr alle verbleibenden S√§tze √ºbernehmen"
  - Aktualisiert nur incomplete Sets
- ‚úÖ UpdateAllSetsUseCase implementiert (Clean Architecture)
  - Domain Layer: Use Case mit Validierung
  - Presentation Layer: SessionStore.updateAllSets()
  - UI Layer: Callbacks durch alle Komponenten
- ‚úÖ Forced Observable Update f√ºr sofortiges UI Feedback
- ‚úÖ Haptic Success Feedback
- ‚úÖ Progressive Overload Integration (lastUsed* wird aktualisiert)

**2. Equipment Display**
- ‚úÖ SessionStore.getExerciseEquipment() implementiert
- ‚úÖ Equipment in CompactExerciseCard angezeigt
- ‚úÖ L√§dt asynchron wie Exercise Names

**3. Debug Improvements**
- ‚úÖ Debug Logging f√ºr markAllSetsComplete()
  - Zeigt Exercise ID, Total Sets, Set Details
  - Hilft "0 sets marked complete" Bug zu diagnostizieren

### ‚úÖ NEU IMPLEMENTIERT (Session 2 - 2025-10-23)

**1. Progressive Overload - Kompletter Cycle**
- ‚úÖ Exercise Names in UI angezeigt (aus Datenbank geladen)
- ‚úÖ ExerciseRepository.fetch(id:) implementiert
- ‚úÖ SessionStore l√§dt Exercise Namen asynchron
- ‚úÖ ActiveWorkoutSheetView zeigt echte Namen statt "√úbung 1, 2, 3"
- ‚úÖ Last Used Values beim Session Start
  - StartSessionUseCase l√§dt lastUsedWeight/Reps aus Exercise-DB
  - Sets starten mit letzten Werten statt Hardcoded Defaults
  - Automatischer Progressive Overload!

**2. UI/UX Verbesserungen**
- ‚úÖ Sofortiges UI Update nach Save (nicht erst beim Abhaken)
  - Forced Observable Update (`currentSession = nil` ‚Üí `currentSession = session`)
  - `.id()` modifier f√ºr CompactExerciseCard basierend auf Set-Werten
- ‚úÖ Rounded Fonts entfernt
  - Alle `.design: .rounded` zu Standard System Font ge√§ndert
  - CompactSetRow, TimerSection, EditSetSheet

### ‚úÖ NEU IMPLEMENTIERT (Session 1 - 2025-10-23)

**1. Editable Weight/Reps**
- ‚úÖ Sheet-basierte Editing UI (statt inline TextFields)
- ‚úÖ Tap auf Weight/Reps √∂ffnet EditSetSheet
- ‚úÖ Gro√üe, gut bedienbare TextFields mit Number Keyboard
- ‚úÖ "Fertig" / "Abbrechen" Buttons
- ‚úÖ Auto-Focus auf Weight-Feld
- ‚úÖ `.presentationDetents([.height(280)])` f√ºr kompakte Sheet-Gr√∂√üe
- ‚úÖ Validierung (weight > 0, reps > 0)
- ‚úÖ Optimistic Updates f√ºr sofortiges UI-Feedback

**2. Exercise History Persistence**
- ‚úÖ ExerciseRepositoryProtocol erstellt
- ‚úÖ SwiftDataExerciseRepository implementiert
- ‚úÖ UpdateSetUseCase aktualisiert ExerciseEntity.lastUsedWeight/Reps/Date
- ‚úÖ Werte werden bei jedem Edit persistiert
- ‚úÖ Bereit f√ºr Progressive Overload (n√§chstes Workout l√§dt letzte Werte)

**3. Exercise Database Seeding**
- ‚úÖ ExerciseSeedData erstellt (3 Test-√úbungen)
  - Bankdr√ºcken (100kg x 8 reps)
  - Lat Pulldown (80kg x 10 reps)
  - Kniebeugen (60kg x 12 reps)
- ‚úÖ Seed l√§uft beim ersten App-Start
- ‚úÖ StartSessionUseCase l√§dt echte Exercise IDs aus Datenbank
- ‚úÖ Keine "Exercise not found" Warnungen mehr

**4. Repository Erweiterungen**
- ‚úÖ ExerciseRepository.findByName() f√ºr Exercise-Lookup
- ‚úÖ ExerciseRepository.fetch(id:) f√ºr Exercise-Details
- ‚úÖ ExerciseRepository.updateLastUsed() f√ºr History
- ‚úÖ StartSessionUseCase nutzt findByName() + fetch() f√ºr Test-Data

### ‚úÖ VORHER IMPLEMENTIERT (Funktioniert)

**1. Clean Architecture Foundation**
- ‚úÖ Domain Layer (Entities, Use Cases, Repository Protocols)
- ‚úÖ Data Layer (SwiftData Repositories, Mappers)
- ‚úÖ Presentation Layer (Stores, Views)
- ‚úÖ Infrastructure Layer (DependencyContainer, SeedData)

**2. Session Management**
- ‚úÖ Start Session Use Case
- ‚úÖ Complete Set Use Case
- ‚úÖ End Session Use Case
- ‚úÖ **Update Set Use Case** (NEU - Weight/Reps editing)
- ‚úÖ Session Repository (SwiftData)
- ‚úÖ Session Mapper (mit in-place updates)

**3. Active Workout UI**
- ‚úÖ Timer Section (Rest + Duration Timer)
- ‚úÖ ScrollView mit allen √úbungen
- ‚úÖ Compact Exercise Cards
- ‚úÖ **Compact Set Rows mit Sheet-Editing** (NEU)
- ‚úÖ Set Completion mit Haptic Feedback
- ‚úÖ Eye-Icon Toggle (Show/Hide completed)
- ‚úÖ Exercise Counter
- ‚úÖ Workout Summary View

**4. State Management**
- ‚úÖ SessionStore (@Observable)
- ‚úÖ RestTimerStateManager
- ‚úÖ DependencyContainer

**5. Persistence**
- ‚úÖ SwiftData Schema (Session + Exercise Entities)
- ‚úÖ Session Restoration
- ‚úÖ **Exercise History Persistence** (NEU)
- ‚úÖ In-Place Updates

---

## üÜï Wichtigste √Ñnderungen dieser Session

### 1. Sheet-Based Editing (statt inline TextFields)

**Problem mit inline TextFields:**
- "Invalid frame dimension" Crashes
- Komplexes Focus Management
- Frame-Berechnungsprobleme in ForEach

**Neue L√∂sung:**
```swift
// CompactSetRow.swift
Button {
    if !set.completed {
        editingWeight = formatNumber(set.weight)
        editingReps = "\(set.reps)"
        showEditSheet = true  // ‚Üê √ñffnet Sheet
    }
} label: {
    HStack(spacing: 4) {
        Text(formatNumber(set.weight))
            .font(.system(size: 28, weight: .bold))
        Text("kg")
            .font(.system(size: 16))
    }
}
.sheet(isPresented: $showEditSheet) {
    EditSetSheet(...)
}
```

**Vorteile:**
- ‚úÖ Keine Crashes
- ‚úÖ Bessere UX (fokussiertes Editing)
- ‚úÖ Standard iOS Pattern
- ‚úÖ Einfaches Keyboard Management
- ‚úÖ Klare "Fertig" / "Abbrechen" Actions

### 2. Exercise History End-to-End

**Workflow:**
```
1. User √§ndert Gewicht 100kg ‚Üí 105kg
   ‚Üì
2. CompactSetRow ‚Üí EditSetSheet
   ‚Üì
3. "Fertig" ‚Üí onUpdateWeight(105.0)
   ‚Üì
4. ActiveWorkoutSheetView ‚Üí sessionStore.updateSet()
   ‚Üì
5. UpdateSetUseCase:
   - Speichert in Session (SessionRepository)
   - Aktualisiert ExerciseEntity (ExerciseRepository)
   ‚Üì
6. ExerciseEntity.lastUsedWeight = 105.0
   ExerciseEntity.lastUsedDate = now()
   ‚Üì
7. N√§chstes Workout: Sets mit 105kg vorausgef√ºllt
```

**Console Output:**
```
‚úèÔ∏è Update weight: setId [...], newWeight 105.0
‚úèÔ∏è Updated local weight to 105.0
‚úÖ Updated exercise Bankdr√ºcken: lastWeight=105.0, lastReps=8
```

### 3. Exercise Seeding

**ExerciseSeedData.swift:**
```swift
static func seedIfNeeded(context: ModelContext) {
    let descriptor = FetchDescriptor<ExerciseEntity>()
    let existingCount = (try? context.fetchCount(descriptor)) ?? 0
    
    if existingCount > 0 {
        print("üìä Exercises already seeded")
        return
    }
    
    // Create 3 test exercises
    let exercises = [
        ExerciseEntity(
            name: "Bankdr√ºcken",
            lastUsedWeight: 100.0,
            lastUsedReps: 8
        ),
        // ... Lat Pulldown, Kniebeugen
    ]
    
    for exercise in exercises {
        context.insert(exercise)
    }
    try context.save()
}
```

**Integration in GymBoApp.swift:**
```swift
@MainActor
private func performStartupTasks() async {
    // Seed exercises on first launch
    ExerciseSeedData.seedIfNeeded(context: container.mainContext)
    
    // Load active session
    await sessionStore.loadActiveSession()
}
```

---

## üèóÔ∏è Projektstruktur (Updated)

```
GymBo/
‚îú‚îÄ‚îÄ Domain/
‚îÇ   ‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WorkoutSession.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SessionExercise.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SessionSet.swift
‚îÇ   ‚îú‚îÄ‚îÄ UseCases/Session/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StartSessionUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompleteSetUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EndSessionUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UpdateSetUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UpdateAllSetsUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddSetUseCase.swift             # ‚Üê NEU (Session 4)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RemoveSetUseCase.swift          # ‚Üê NEU (Session 4)
‚îÇ   ‚îî‚îÄ‚îÄ RepositoryProtocols/
‚îÇ       ‚îú‚îÄ‚îÄ SessionRepositoryProtocol.swift
‚îÇ       ‚îî‚îÄ‚îÄ ExerciseRepositoryProtocol.swift
‚îÇ
‚îú‚îÄ‚îÄ Data/
‚îÇ   ‚îú‚îÄ‚îÄ Repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SwiftDataSessionRepository.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SwiftDataExerciseRepository.swift # ‚Üê NEU
‚îÇ   ‚îú‚îÄ‚îÄ Mappers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SessionMapper.swift
‚îÇ   ‚îî‚îÄ‚îÄ SwiftDataEntities.swift              # ExerciseEntity mit lastUsed*
‚îÇ
‚îú‚îÄ‚îÄ Presentation/
‚îÇ   ‚îú‚îÄ‚îÄ Stores/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SessionStore.swift               # addSet(), removeSet() added
‚îÇ   ‚îî‚îÄ‚îÄ Views/ActiveWorkout/Components/
‚îÇ       ‚îú‚îÄ‚îÄ CompactSetRow.swift              # ‚Üê Sheet-based editing
‚îÇ       ‚îú‚îÄ‚îÄ CompactExerciseCard.swift        # ‚Üê Quick-Add + Context Menu
‚îÇ       ‚îî‚îÄ‚îÄ EditSetSheet.swift               # ‚Üê in CompactSetRow.swift
‚îÇ
‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ DI/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DependencyContainer.swift        # ExerciseRepository added
‚îÇ   ‚îî‚îÄ‚îÄ SeedData/
‚îÇ       ‚îî‚îÄ‚îÄ ExerciseSeedData.swift           # ‚Üê NEU
‚îÇ
‚îî‚îÄ‚îÄ GymBoApp.swift                           # Seed-Aufruf added
```

---

## üîß Technische Details (Updated)

### 1. AddSetUseCase (Session 4)

```swift
final class DefaultAddSetUseCase: AddSetUseCase {
    private let repository: SessionRepositoryProtocol
    private let exerciseRepository: ExerciseRepositoryProtocol

    func execute(
        sessionId: UUID,
        exerciseId: UUID,
        weight: Double?,
        reps: Int?
    ) async throws -> DomainWorkoutSession {
        // 1. Fetch active session
        guard var session = try await repository.fetchActiveSession() else {
            throw AddSetError.sessionNotFound(sessionId)
        }

        // 2. Find exercise index
        guard let exerciseIndex = session.exercises.firstIndex(
            where: { $0.id == exerciseId }
        ) else {
            throw AddSetError.exerciseNotFound(exerciseId)
        }

        // 3. Determine weight and reps (fallback to last set's values)
        let lastSet = session.exercises[exerciseIndex].sets.last
        let finalWeight = weight ?? lastSet?.weight ?? 0.0
        let finalReps = reps ?? lastSet?.reps ?? 0

        // 4. Create new set
        let newSet = DomainSessionSet(
            weight: finalWeight,
            reps: finalReps,
            completed: false
        )

        // 5. Add set to exercise
        session.exercises[exerciseIndex].sets.append(newSet)

        // 6. Persist changes
        try await repository.update(session)

        // 7. Update exercise history
        try? await exerciseRepository.updateLastUsed(
            exerciseId: session.exercises[exerciseIndex].catalogExerciseId,
            weight: finalWeight,
            reps: finalReps,
            date: Date()
        )

        return session
    }
}
```

### 2. RemoveSetUseCase (Session 4)

```swift
final class DefaultRemoveSetUseCase: RemoveSetUseCase {
    private let repository: SessionRepositoryProtocol

    func execute(
        sessionId: UUID,
        exerciseId: UUID,
        setId: UUID
    ) async throws -> DomainWorkoutSession {
        // 1. Fetch active session
        guard var session = try await repository.fetchActiveSession() else {
            throw RemoveSetError.sessionNotFound(sessionId)
        }

        // 2. Find exercise and set indices
        guard let exerciseIndex = session.exercises.firstIndex(
            where: { $0.id == exerciseId }
        ) else {
            throw RemoveSetError.exerciseNotFound(exerciseId)
        }

        guard let setIndex = session.exercises[exerciseIndex].sets.firstIndex(
            where: { $0.id == setId }
        ) else {
            throw RemoveSetError.setNotFound(setId)
        }

        // 3. Business rule: Cannot remove last set
        guard session.exercises[exerciseIndex].sets.count > 1 else {
            throw RemoveSetError.cannotRemoveLastSet
        }

        // 4. Remove set
        session.exercises[exerciseIndex].sets.remove(at: setIndex)

        // 5. Persist changes
        try await repository.update(session)

        return session
    }
}
```

### 3. Quick-Add Field Regex Parser

```swift
// In CompactExerciseCard.swift
private func parseSetInput(_ input: String) -> (weight: Double, reps: Int)? {
    // Regex: "100 x 8" or "100.5 √ó 12" or "80X10"
    let pattern = #"(\d+(?:\.\d+)?)\s*[xX√ó]\s*(\d+)"#

    guard let regex = try? NSRegularExpression(pattern: pattern),
          let match = regex.firstMatch(
              in: input,
              range: NSRange(input.startIndex..., in: input)
          ),
          match.numberOfRanges == 3 else {
        return nil
    }

    // Extract weight (group 1)
    let weightRange = Range(match.range(at: 1), in: input)!
    let weightString = String(input[weightRange])

    // Extract reps (group 2)
    let repsRange = Range(match.range(at: 2), in: input)!
    let repsString = String(input[repsRange])

    guard let weight = Double(weightString),
          let reps = Int(repsString),
          weight > 0,
          reps > 0 else {
        return nil
    }

    return (weight, reps)
}
```

### 4. UpdateSetUseCase

```swift
final class DefaultUpdateSetUseCase: UpdateSetUseCase {
    private let repository: SessionRepositoryProtocol
    private let exerciseRepository: ExerciseRepositoryProtocol
    
    func execute(
        sessionId: UUID,
        exerciseId: UUID,
        setId: UUID,
        weight: Double? = nil,
        reps: Int? = nil
    ) async throws -> DomainWorkoutSession {
        // 1. Update Session
        // ... (update set in session)
        try await repository.update(session)
        
        // 2. Update Exercise History
        let finalWeight = set.weight
        let finalReps = set.reps
        
        try? await exerciseRepository.updateLastUsed(
            exerciseId: catalogExerciseId,
            weight: finalWeight,
            reps: finalReps,
            date: Date()
        )
        
        return session
    }
}
```

### 5. ExerciseRepository

```swift
protocol ExerciseRepositoryProtocol {
    func updateLastUsed(
        exerciseId: UUID,
        weight: Double,
        reps: Int,
        date: Date
    ) async throws
    
    func findByName(_ name: String) async throws -> UUID?
}

// SwiftData Implementation
final class SwiftDataExerciseRepository: ExerciseRepositoryProtocol {
    func updateLastUsed(...) async throws {
        let descriptor = FetchDescriptor<ExerciseEntity>(
            predicate: #Predicate { $0.id == exerciseId }
        )
        
        guard let exercise = try modelContext.fetch(descriptor).first else {
            return // Silently ignore if not found
        }
        
        exercise.lastUsedWeight = weight
        exercise.lastUsedReps = reps
        exercise.lastUsedDate = date
        
        try modelContext.save()
    }
}
```

### 6. ExerciseEntity Schema

```swift
@Model
final class ExerciseEntity {
    var id: UUID
    var name: String
    
    // Exercise History (f√ºr Progressive Overload)
    var lastUsedWeight: Double?     // ‚Üê NEU persistiert
    var lastUsedReps: Int?          // ‚Üê NEU persistiert
    var lastUsedDate: Date?         // ‚Üê NEU persistiert
    var lastUsedSetCount: Int?
    var lastUsedRestTime: TimeInterval?
    
    // ... muscleGroups, equipment, etc.
}
```

---

## üêõ Behobene Bugs (diese Session)

### ~~6. TextField Crashes (Invalid frame dimension)~~ ‚úÖ GEFIXT
**Problem:** Inline TextFields verursachten Frame-Berechnungsfehler  
**Versuche:**
- `.fixedSize()` statt `.frame(minWidth:)` ‚Üí Crash
- Toolbar an verschiedenen Stellen ‚Üí Crash
- Focus Management mit onChange ‚Üí Crash  

**Finale L√∂sung:** Komplett anderer Ansatz
- Sheet-based Editing statt inline TextFields
- Keine Frame-Berechnungen in ForEach
- Separate EditSetSheet View
- Standard iOS Pattern

**Status:** ‚úÖ FUNKTIONIERT perfekt

### ~~7. Exercise not found Warnings~~ ‚úÖ GEFIXT
**Problem:** `‚ö†Ô∏è Exercise not found: F5BEEF6D-...`  
**Ursache:** StartSessionUseCase verwendete random UUIDs  
**Fix:**
- Exercise Database Seeding implementiert
- StartSessionUseCase l√§dt echte IDs via `findByName()`
- UpdateSetUseCase findet jetzt die Exercises

**Status:** ‚úÖ FUNKTIONIERT

---

## ‚è≥ Was FEHLT noch (TODO)

### 1. ~~Exercise Names in UI~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT
**Implementiert:** ActiveWorkoutSheetView l√§dt Namen via SessionStore.getExerciseName()

### 2. ~~Load Last Used Values on Session Start~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT
**Implementiert:** StartSessionUseCase nutzt lastUsedWeight/Reps aus Exercise-DB

### 3. ~~Update All Sets Feature~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT
**Implementiert:** UpdateAllSetsUseCase + Toggle in EditSetSheet

### 4. ~~Equipment Display~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT
**Implementiert:** SessionStore.getExerciseEquipment() + UI Integration

### 5. ~~Mark All Complete Bug~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ GEFIXT (Session 3)
**Problem:** UI zeigte keine gr√ºnen Haken nach Mark All Complete
**Fix:** Forced Observable Update mit fresh session fetch

### 6. ~~Add/Remove Sets w√§hrend Session~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT (Session 4)
**Implementiert:**
- AddSetUseCase + RemoveSetUseCase
- Quick-Add Field mit Regex Parser
- Plus Button mit Last-Set Fallback
- Long-Press Context Menu f√ºr Delete
- Business Rules (Cannot delete last set)

### 7. ~~Workout Repository~~ ‚úÖ ERLEDIGT
**Status:** ‚úÖ KOMPLETT (Session 5)
**Implementiert:**
- Vollst√§ndige Clean Architecture (Domain ‚Üí Data ‚Üí Presentation)
- WorkoutRepositoryProtocol + SwiftDataWorkoutRepository
- GetAllWorkoutsUseCase + GetWorkoutByIdUseCase
- WorkoutStore + Workout Picker UI
- Workout Seed Data (Push/Pull/Legs)
- StartSessionUseCase l√§dt echte Workouts
- Progressive Overload mit lastUsed Values

### 8. ~~Progression Features (Phase 2)~~ üìã DOKUMENTIERT
**Status:** üìã Vollst√§ndig geplant (PROGRESSION_FEATURE_PLAN.md)
**Gesch√§tzt:** ~14 Stunden Implementation
**Enth√§lt:**
- Data Model Extensions (optional, backward compatible)
- 3 Progression Strategien (Linear, Double, Wave Loading)
- Use Cases: SuggestProgressionUseCase, RecordProgressionEventUseCase
- UI: Progression Banner, Settings, Timeline
- ProgressionEventEntity f√ºr History Tracking

### 9. Reorder Exercises/Sets
**Status:** üî¥ FEHLT
**UI:** Buttons vorhanden
**Ben√∂tigt:** Drag & Drop + `ReorderUseCase`

### 10. Workout History & Statistics
**Status:** üî¥ FEHLT

### 11. Tests
**Status:** üî¥ FEHLT

---

## üìã N√§chste Schritte (Empfehlung)

### Quick Wins (30-60 Min)

1. **~~"Mark All Complete" Button~~ ‚úÖ ERLEDIGT (Session 3)**
   - ‚úÖ Bug gefixt (UI Refresh mit forced Observable update)
   - ‚úÖ Workout Summary Persistence gefixt
   - ‚úÖ Workout Complete Message implementiert

2. **~~Equipment in UI anzeigen~~ ‚úÖ ERLEDIGT (Session 3)**
   - ‚úÖ SessionStore.getExerciseEquipment()
   - ‚úÖ CompactExerciseCard zeigt Equipment
   - ‚úÖ Asynchrones Laden wie Exercise Names

3. **~~Add/Remove Sets~~ ‚úÖ ERLEDIGT (Session 4)**
   - ‚úÖ AddSetUseCase implementiert
   - ‚úÖ Quick-Add TextField mit Regex Parser ("100 x 8")
   - ‚úÖ RemoveSetUseCase + Long-Press Context Menu
   - ‚úÖ Business Rules (Cannot delete last set)

### Mittelfristig (4-8 Stunden)

4. **~~Workout Repository~~ ‚úÖ ERLEDIGT (Session 5)**
   - ‚úÖ Clean Architecture komplett implementiert
   - ‚úÖ Workout Picker in HomeView
   - ‚úÖ Echte Templates (Push/Pull/Legs)
   - ‚úÖ Progressive Overload funktioniert

5. **Reordering (2-3 Stunden)**
   - `.onMove` f√ºr Exercises
   - `.onMove` f√ºr Sets  
   - ReorderUseCase

6. **Progression Features - Phase 2 (~14 Stunden)**
   - Siehe PROGRESSION_FEATURE_PLAN.md
   - Data Model Extensions
   - Progression Strategies Implementation
   - UI Components (Banner, Settings, Timeline)

---

## üéì Lessons Learned (Updated)

### 5. SwiftUI TextField in ForEach ist problematisch
**Problem:** Inline TextFields in ForEach ‚Üí Frame-Crashes  
**L√∂sung:** Sheet-based Editing Pattern
- Separate View f√ºr Editing
- Keine Frame-Berechnungen im Loop
- Bessere UX durch fokussierte UI

### 6. Progressive Overload braucht Exercise History
**Wichtig:** ExerciseEntity.lastUsed* ist fundamental
- Nutzer will sehen: "Letztes Mal: 100kg x 8"
- N√§chstes Training: Automatisch vorausgef√ºllt
- Foundation f√ºr Progression Tracking

### 7. Database Seeding ist essential f√ºr Development
**Warum:** Ohne Seed-Data sind IDs random
- Exercise History funktioniert nicht
- Testing ist schwierig
- UX leidet (keine Namen, keine History)

### 8. Clean Architecture zahlt sich aus
**Learnings aus Session 5:**
- Workout Repository in 3-4h implementiert (durch klare Layer)
- Keine Breaking Changes (optional fields, backward compatible)
- Wiederverwendung von WorkoutEntity (bereits vorhanden)
- Testing: MockRepositories funktionieren perfekt
- Dependency Injection macht alles einfach austauschbar

---

## üöÄ Current State Summary

**Was jetzt funktioniert (End-to-End):**

1. ‚úÖ **App Start** ‚Üí Seeds 3 Exercises + 4 Workouts (first launch)
2. ‚úÖ **Workout Picker** ‚Üí Liste mit Favoriten (Push/Pull/Legs/TEST)
3. ‚úÖ **Start Workout** ‚Üí L√§dt echtes Workout Template aus DB
4. ‚úÖ **Exercise Names** ‚Üí Echte Namen aus Workout
5. ‚úÖ **Progressive Overload** ‚Üí Sets starten mit letzten Werten
6. ‚úÖ **Exercise Reordering** ‚Üí Drag & Drop mit permanentem Speichern
   - Reorder-Button in Toolbar √∂ffnet Sheet
   - Toggle "Reihenfolge dauerhaft speichern"
   - Session-only ODER Workout Template Update
7. ‚úÖ **Tap Weight/Reps** ‚Üí Sheet √∂ffnet sich
8. ‚úÖ **Edit Values** ‚Üí Gro√üe, gut bedienbare TextFields
9. ‚úÖ **Update All Sets** ‚Üí Toggle f√ºr alle incomplete Sets
10. ‚úÖ **Add Set** ‚Üí Quick-Add Field ("100 x 8") + Plus Button
11. ‚úÖ **Delete Set** ‚Üí Long-Press Context Menu
12. ‚úÖ **Auto-Finish Exercise** ‚Üí Automatisch ausgeblendet nach letztem Satz
13. ‚úÖ **Mark All Complete** ‚Üí Alle Sets auf einmal abhaken (FinishExerciseUseCase)
14. ‚úÖ **Workout Complete** ‚Üí Summary Sheet mit Statistiken
15. ‚úÖ **Exercise History** ‚Üí lastUsedWeight/Reps/Date persistiert
16. ‚úÖ **N√§chstes Training** ‚Üí Selbes Workout, neue Progressive Overload Values!

**Komplettes Set Management:**
- ‚úÖ Edit Set (Sheet-based UI)
- ‚úÖ Update All Sets (Toggle)
- ‚úÖ Add Set (Quick-Add + Plus Button)
- ‚úÖ Delete Set (Context Menu)
- ‚úÖ Mark All Complete (Batch operation)
- ‚úÖ Auto-Finish (when all sets completed)

**Exercise Management:**
- ‚úÖ Exercise Reordering (Session-only + Permanent Save)
- ‚úÖ Auto-Hide finished exercises
- ‚úÖ Eye-Toggle (Show/Hide finished)
- ‚úÖ Production-ready orderIndex handling

**Workout Management:**
- ‚úÖ Workout Repository (Clean Architecture)
- ‚úÖ Workout Picker UI mit Favoriten
- ‚úÖ 4 Seed Workouts (Push/Pull/Legs/TEST Multi Exercise)
- ‚úÖ Real Workout Loading in StartSessionUseCase
- ‚úÖ Progressive Overload Integration
- ‚úÖ Permanent Reorder Save zu Workout Template

---

## üìö Verwandte Dokumentation

- `TECHNICAL_CONCEPT_V2.md` - Architektur-Specs
- `UX_CONCEPT_V2.md` - UX/UI Design
- `TODO.md` - Priorisierte Aufgaben + Phase 2 Sektion
- `README.md` - Projekt-√úbersicht
- `PROGRESSION_FEATURE_PLAN.md` - ‚≠ê Phase 2 Spec (Auto-Progression, ~14h)
- `PROGRESSION_QUICK_REF.md` - ‚≠ê Phase 2 Quick Reference
- `SESSION_SUMMARY_2025_10_23.md` - Session 5 Detailed Summary

---

**Letzte Aktualisierung:** 2025-10-23 (Session 5 Ende)
**Status:** ‚úÖ WORKOUT REPOSITORY KOMPLETT! Real Workouts + Progressive Overload + Complete Set Management!
**N√§chste Session:** Reordering, Progression Features (Phase 2), oder Workout History & Statistics
